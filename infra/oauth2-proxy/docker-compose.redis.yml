services:
  oauth2-proxy:
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
    image: quay.io/oauth2-proxy/oauth2-proxy:v7.13.0
    container_name: oauth2-proxy
    restart: unless-stopped
    # [1] 설정 파일 로드 명령
    command: --config /etc/oauth2-proxy.cfg
    environment:
      # [2] 시스템 레벨 환경 변수 (설정 파일로 대체 불가)
      # SSL 인증서 로드는 앱 로직 이전에 Go 언어 런타임에서 처리하므로 Env에 있어야 함
      - SSL_CERT_FILE=/etc/ssl/certs/rootCA.pem
      - OAUTH2_PROXY_CLIENT_SECRET=${OAUTH2_PROXY_CLIENT_SECRET}
      - OAUTH2_PROXY_COOKIE_SECRET=${OAUTH2_PROXY_COOKIE_SECRET}
      - OAUTH2_PROXY_REDIS_CONNECTION_URL=redis://:${REDIS_PASSWORD}@oauth2-proxy-redis:6379
    volumes:
      # 호스트의 mkcert RootCA를 컨테이너 내부로 주입
      - ./config/oauth2-proxy.cfg:/etc/oauth2-proxy.cfg:ro
      - ./certs/rootCA.pem:/etc/ssl/certs/rootCA.pem:ro
    extra_hosts:
      - "keycloak.${DEFAULT_URL}:host-gateway"
      - "auth.${DEFAULT_URL}:host-gateway"
    labels:
      - "traefik.enable=true"
      # OAuth2 콜백 처리를 위한 라우터
      - "traefik.http.routers.oauth2-proxy.rule=Host(`auth.${DEFAULT_URL}`)"
      - "traefik.http.routers.oauth2-proxy.entrypoints=websecure"
      - "traefik.http.routers.oauth2-proxy.tls=true"
      - "traefik.http.services.oauth2-proxy.loadbalancer.server.port=${OAUTH2_PROXY_PORT}"
    networks:
      infra_net:
        ipv4_address: 172.19.0.28
    logging:
      driver: 'json-file'
      options:
        max-size: '5m'
        max-file: '2'

  oauth2-proxy-redis:
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
    image: redis:8.4.0-bookworm  # Redis 8.4.x
    container_name: oauth2-proxy-redis
    secrets:
      - redis_password
    networks:
      infra_net:
        ipv4_address: 172.19.0.18
    restart: unless-stopped
    volumes:
      # 공통 redis.conf
      - oauth2-proxy-redis-data:/data
    command: >
      sh -c '
      redis-server
      --requirepass "$(cat /run/secrets/redis_password)"
      --appendonly yes
      --port 6379
      '
    # 클러스터 내부 통신 포트는 expose
    expose:
      - "${REDIS_PORT}"
      - "${REDIS_BUS_PORT}"
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "REDIS_PASSWORD=$(cat /run/secrets/redis_password); redis-cli -a $REDIS_PASSWORD -h 127.0.0.1 -p 6379 ping | grep PONG",
        ]
      interval: 10s
      timeout: 3s
      retries: 5
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "2"

  oauth2-proxy-redis-exporter:
    deploy:
      resources:
        limits:
          cpus: '0.1'
          memory: 128M
    image: oliver006/redis_exporter:v1.80.1-alpine
    container_name: oauth2-proxy-redis-exporter
    expose:
      - "${REDIS_EXPORTER_PORT}"
    networks:
      infra_net:
        ipv4_address: 172.19.0.19
    restart: unless-stopped
    secrets:
      - redis_password
    entrypoint:
      - /bin/sh
      - -c
    command:
      - |
        echo "Reading password from secret..."
        export REDIS_PASSWORD=$(cat /run/secrets/redis_password | tr -d '\n')

        echo "Starting Redis Exporter..."
        # -redis.password-file 대신 -redis.password 사용
        exec /redis_exporter \
          -redis.addr=redis://oauth2-proxy-redis:6379 \
          -redis.password="$REDIS_PASSWORD" \
          -web.listen-address=:${REDIS_EXPORTER_PORT}
    depends_on:  # healthcheck를 사용하므로 condition으로 변경 (더 안정적)
      oauth2-proxy-redis:
        condition: service_healthy
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "2"

volumes:  
  oauth2-proxy-redis-data:
    # driver: local
    # driver_opts:
    #   o: bind
    #   type: none
    #   device: ${DEFAULT_REDIS_DATA_DIR}/oauth2-proxy-node

networks:
  infra_net:
    external: true